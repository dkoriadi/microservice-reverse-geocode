
const axios = require('axios')

const jwtGenToken = require('./oauth2/jwt-sign');
const jwtVerifyToken = require('./oauth2/jwt-verify');

let response;

var host = 'https://nominatim.openstreetmap.org';

/**
 *
 * Event doc: https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html#api-gateway-simple-proxy-for-lambda-input-format
 * @param {Object} event - API Gateway Lambda Proxy Input Format
 *
 * Context doc: https://docs.aws.amazon.com/lambda/latest/dg/nodejs-prog-model-context.html 
 * @param {Object} context
 *
 * Return doc: https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html
 * @returns {Object} object - API Gateway Lambda Proxy Output Format
 * 
 */
exports.lambdaHandler = async (event, context) => {
    //console.log(JSON.stringify(event));

    // If a POST request is sent to this Lambda function, return a token 
    // based on credentials instead of proceeding further
    if (event.httpMethod === 'POST' || (event.requestContext.http && event.requestContext.http.method === 'POST')) {
        var token = await jwtGenToken.generateSignedJwt(event);
        if (!token) {
            // Invalid user credentials, return 401
            response = {
                'statusCode': 401,
                headers: {
                    "Content-Type" : "application/json"
                },
                body: JSON.stringify("Bad credentials")
            }
            return response
        }

        // Valid user credentials, return bearer token (JWT) with expiry time
        // of 1 hour (3600 seconds). If expiry time is to be updated, also
        // update it during the signing of the JWT.
        response = {
            'statusCode': 200,
            headers: {
                "Content-Type" : "application/json"
            },
            body: JSON.stringify( {
                "token_type" : "Bearer",
                "expires_in": 3599,
                "access_token" : token
            })
        }
        return response
    }

    // GET request is sent to Lambda function, verify JWT token first
    var result = await jwtVerifyToken.verifySignedJwt(event);
    if (!result.isAuthorized) {
        // Bad token
        response = {
            'statusCode': 401,
            headers: {
                "Content-Type" : "application/json"
            },
            body: JSON.stringify(result.context.message)
        }
        return response
    }

    // Valid token, now check if query string containing latitude and longitude is a float
    if(!event.queryStringParameters || isNaN(parseFloat(event.queryStringParameters.lat)) || 
                                       isNaN(parseFloat(event.queryStringParameters.lon))
    ) {
        // Not a float, return 400
        response = {
            'statusCode': 400,
            headers: {
                "Content-Type" : "application/json"
            },
            body: JSON.stringify("Bad request")
        }
        return response    
    }

    // Valid token, valid query, get the address from reverse geocode
    const queryResults = await fetchReverseGeocode(event.queryStringParameters.lat, event.queryStringParameters.lon);
    if (!queryResults.address) {
        // Since we checked the query previously for correctness, we should not 
        // end up here anyways
        response = {
            'statusCode': 400,
            headers: {
                "Content-Type" : "application/json"
            },
            body: JSON.stringify(queryResults)
        }
        return response
    }
    
    // All is good
    response = {
        'statusCode': 200,
        headers: {
            "Content-Type" : "application/json"
        },
        body: JSON.stringify(queryResults)
    }
    return response
};

/**
 * Send a GET request to OpenStreetMap reverse geocoding web service to 
 * retrieve an address based on the latitude and longitude.
 *
 * @param {float} lat - Access token generated by Azure AD
 * 
 * @param {float} lon - Entity selected
 * 
 * @returns {Promise<Object>} data - JSON object containing address, latitude and 
 *                                   longitude 
 * 
 * @throws If an error is returned from the service, the error message is 
 *         logged and returned 
 * 
 */
async function fetchReverseGeocode(lat, lon) {
    // Axios library wants it this way
    let config = {
        headers: 
        {
            'Accept': 'application/json',
        }
    }
    
    try {
        // Make the GET request, axios returns JSON object by default
        var url = `${host}/reverse?format=json&lat=${lat}&lon=${lon}`;
        var ret = await axios.get(url, config);
        // If no result matches query string parameters, null is returned
        var address = ret.data.hasOwnProperty("display_name") ? ret.data.display_name : null;
        return {
            "lat" : lat,
            "lon" : lon,
            "address" : address
        };
    }
    catch (error) {
		if (error.response) {
			// The request was made and the server responded with a status code
			// that falls out of the range of 2xx
			console.log(error.response.data);
			console.log(error.response.status);
			//console.log(error.response.headers);
            return {
                "lat" : lat,
                "lon" : lon,
                "error_message" : error.response.data.error.message
            };
		} else if (error.request) {
			// The request was made but no response was received
			// `error.request` is an instance of XMLHttpRequest in the browser and an instance of
			// http.ClientRequest in node.js
			console.log(error.request);
		} else {
			// Something happened in setting up the request that triggered an Error
			console.log('Error', error.message);
		}
		console.log(error.config);
	}

}
